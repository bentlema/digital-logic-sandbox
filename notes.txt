
Brainstorming on how I want the GUI to work...

I want to be able to define the primative gates via the GUI, so theoretically
the code itself would not implement the various logic gates (AND, OR, NOT, etc.)
but rather, the user of the software would define those using the app itself.

Each gate would be defined by specifying the number of inputs.
The number of outputs is not specified, as there will always only ever be a
single output.

Gates with both inputs and outputs would be relatively easy to implement, but
we need to make sure we have a way to also define components that do not have
an input--only an output--such as a clock source, fixed HI or fixed LO signal,
or a toggle switch.  The fixed HI/LO component would just be a special case
of a toggle switch, and the clock source could be a toggle switch that automatically
toggles itself every second (or other time length).

Define Simple Gate / Component:

         /    0 Inputs / 1 Output   (Used for a switch, clock source, fixed high, fixed low)
 Choose <     1 Input  / 1 Output   (Used for a NOT gate / Inverter)
         \    2 Inputs / 1 Output   (Used for AND, OR, XOR, NAND, NOR, XNOR)

Potential Object Attributes...

   - Type:
      * Input Component (Switch, Clock, Fixed HI/LO)
      * Output Component (LED, 7-Segment display)
      * Gate (AND, OR, XOR, NAND, NOR, XNOR, NOT)
      * Integrated Circuit (wrapper around a circuit which attaches inputs and outputs?)

   - Inputs dict
      * Input label

   - Outputs dict
      * Output label

   - Relationship between inputs and outputs
      * Strings such as 'AND' would map to the python 'and' operator, etc.
      * Implement as truth table?
      * Optimize with K-Map?


Python only implements:  AND, OR, NOT, but we can use the bitwise XOR since we are working with Boolean types

Hash of 2-dimensional arrays:



#
# Make 2x2 matrix (2-dimensional list/array)
#

and_truth = [[0 for x in range(2)] for y in range(2)]

#
# Populate the 2x2 array with values for and AND gate
#

and_truth[0][0] = 0
and_truth[0][1] = 0
and_truth[1][0] = 0
and_truth[1][1] = 1

#
# Plop the 2x2 into a hash keyed off of gate type/name
#

truth_dict = {}
truth_dict['AND'] = and_truth

#
# Show the value to prove the data structure is correct
#

truth_dict['AND'][0][0]
truth_dict['AND'][0][1]
truth_dict['AND'][1][0]
truth_dict['AND'][1][1]

AND

 P   Q  Out
--- --- ---
 0   0   0
 0   1   0
 1   0   0
 1   1   1

OR

 P   Q  Out
--- --- ---
 0   0   0
 0   1   1
 1   0   1
 1   1   1

XOR (The carrot ^ operator in Python)

 P   Q  Out
--- --- ---
 0   0   0
 0   1   1
 1   0   1
 1   1   0

NOT

 P   Out
--- ---
 0   1
 1   0


foo = andGate()
foo.printState()
foo.toggleInputStateByName('IN_0')
foo.printState()
foo.toggleInputStateByName('IN_1')
foo.printState()
foo.toggleInputStateByName('IN_0')
foo.printState()
foo.toggleInputStateByName('IN_1')
foo.printState()

bar = orGate()
bar.printState()
bar.toggleInputStateByName('IN_0')
bar.printState()
bar.toggleInputStateByName('IN_1')
bar.printState()
bar.toggleInputStateByName('IN_0')
bar.printState()
bar.toggleInputStateByName('IN_1')
bar.printState()

lah = xorGate()
lah.printState()
lah.toggleInputStateByName('IN_0')
lah.printState()
lah.toggleInputStateByName('IN_1')
lah.printState()
lah.toggleInputStateByName('IN_0')
lah.printState()
lah.toggleInputStateByName('IN_1')
lah.printState()

dee = notGate()
dee.printState()
dee.toggleInputStateByName('IN_0')
dee.printState()
dee.toggleInputStateByName('IN_0')
dee.printState()




Okay, right now we have a generic logicGate class.
We also have specific gates that inherit from the logicGate class.
The behavior of the specific gates is hard-coded, like a primative.
For example, we have an andGate, orgate, xorGate, notGate.
Questions:
   - do we really want to have these primatives?
   - would the code be easier to maintain if we "created" each of these gates with their behavior dynamically?
   - what if we could create the primative gates at startup, rather than having them hard coded?


andGate = logicGate('AND')         # Give it a name
andGate.createInputConnection(2)   # add 2 inputConnections
andGate.createOutputConnection(1)  # add 1 outputConnection (could a gate have more than 1 output connection?)

# Build the truth table for an AND gate
and_truth = [[0 for x in range(2)] for y in range(2)]
and_truth[0][0] = 0
and_truth[0][1] = 0
and_truth[1][0] = 0
and_truth[1][1] = 1

# Configure the gate to use the truth table
andGate.defineTruthTable(and_truth)

At this point we'd have a gate the behaves like an AND gate

Anyway, we'd still end up defining an andGate class, because we would want to
be able to create many many instances of an andGate, and we don't want to have
to write all of that code every time to create 1 gate dynamically.

The interesting thing to consider is, with all outputs pre-calculated, would
it be faster than calculating the output with the logical operators?

Using the truth table method is certainly more general, and would make it easy
to create, say, 3 or more input gates if we wanted to (like a 3 input AND gate).

In fact, if we were using the truth table to define gate behavior, we could
even make a fullAdder "gate" with 2-inputs and 2-outputs.  This is a case where
we'd have more than one output.  Interesting.

Need to start looking at how we will implement gate connections, so we can
connect one gate to another gate through a "Wire" object.  We need a wire
object so that we can eventually draw the wire on the screen, and eventually
we may want to be able to implement latency, so all gates and wire could have
a certain amount of latency.  We'd then be able to implement the "Buffer"
gate, which is really just like a wire with some latency/delay.


We also need "special purpose gates" that arn't really gates, but circuit
elements:

Input elements:

1) Toggle Switch (input that we can flip on/off via the GUI)
2) Clock source (really like a toggle switch that toggles on/off automatically at certain Hz rate)
3) Fixed HI source (really just a toggle switch that is always on/1/true)
4) Fixed LO source (really just a toggle switch that is always off/0/false)

Output elements:

1) an LED / lamp - some GUI element that would indicate if the signal is HI/LO, ON/OFF, 0/1, true/false
2) 7-segment display (really just 8 LED's aranged in a special way, 8th is the decimal point)






i2 = [
    (0, 0),
    (0, 1),
    (1, 0),
    (1, 1)
    ]

i3 = [
    (0, 0, 0),
    (0, 0, 1),
    (0, 1, 0),
    (0, 1, 1),
    (1, 0, 0),
    (1, 0, 1),
    (1, 1, 0),
    (1, 1, 1)
    ]


for x, y, z in i3:
   print("x {} y {} z {}".format(x,y,z))



i4 = [
    (0, 0, 0, 0),
    (0, 0, 0, 1),
    (0, 0, 1, 0),
    (0, 0, 1, 1),
    (0, 1, 0, 0),
    (0, 1, 0, 1),
    (0, 1, 1, 0),
    (0, 1, 1, 1),
    (1, 0, 0, 0),
    (1, 0, 0, 1),
    (1, 0, 1, 0),
    (1, 0, 1, 1),
    (1, 1, 0, 0),
    (1, 1, 0, 1),
    (1, 1, 1, 0),
    (1, 1, 1, 1)
    ]

for w, x, y, z in i4:
   print("w {} x {} y {} z {}".format(w,x,y,z))


for a in i4:
   print(a)



How would we implement the truthTable is there could be more than one output, say in the case of a Full Adder?

A_IN "Number A Input"
B_IN  "Number B Input"
C_IN  "Carry Input"
S_OUT "Sum Output"
C_OUT "Carry Output"

A_IN  B_IN  C_IN   S_OUT C_OUT
----- ----- -----  ----- -----
  0     0     0      0     0
  0     0     1      1     0
  0     1     0      1     0
  0     1     1      0     1
  1     0     0      1     0
  1     0     1      0     1
  1     1     0      0     1
  1     1     1      1     1

Thought:  Let's not implement this more general case, as we'd end up with an "optimized" gate to work
like a full-adder, instead of an IC that was built with the primative gates, and the latency would not
be realistic as a result.  The "Full Adder Gate" would be artificially fast.  However, we could set
the latency to represent whatever the realistic speed would be. I eventually want to implement this
more general "gate by truth table" idea, but will keep it simple for now...

It would still be cool to be able to print out a truth table for any IC.  We could build an input
component that would be multiple clock sources (one for each input), and that would be set to different
rates to ensure all inputs are covered.  For example, for a 4-input IC, we could use 4 clock sources
with their rate set to:

1 Hz 0101010101010101 0101010101010101 0101010101010101
2 Hz 0011001100110011 0011001100110011 0011001100110011
4 Hz 0000111100001111 0000111100001111 0000111100001111
8 Hz 0000000011111111 0000000011111111 0000000011111111



